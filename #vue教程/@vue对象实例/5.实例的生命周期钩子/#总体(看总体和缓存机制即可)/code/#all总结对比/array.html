<meta charset="utf-8">
<script src="https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.js"></script>
<script src="https://cdn.bootcss.com/vuex/3.0.1/vuex.js"></script>
<script src="https://cdn.bootcss.com/axios/0.18.0/axios.min.js"></script>
<script src="https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js"></script>


<div id="app">

    <span v-for="item in todo">{{item}} </span>

    <hr>
    <!-- 和上面没差别 一样监视不了-->
    {{todo[0]}} {{todo[1]}}
    <hr>
    <!-- 和上面没差别 一样监视不了-->
    {{todo1}}
    <hr>
    <!--    push变异方法,watch浅度监听也可以监听到-->
    <button @click="todo.push(2)" class="btn-success">todo.push(2)</button>
    <!--    不能监听到修改已有的赋值-->
    <button @click="todo[0]=10">todo[0]=10</button>
    <!--    不能监听到添加新键值-->
    <button @click="todo[1]=2">todo[1]=2</button>
    <!--    不能监听到assign添加新键值-->
    <button @click="Object.assign(todo,[10,2])">Object.assign(todo,[10,2])</button>
    <!--    可以监听到添加新键值-->
    <button @click="$set(todo,'1',2)" class="btn-success">$set(todo,'1',2)"</button>

</div>


<script>


    const vm = new Vue({
        el: '#app',
        data: {
            todo: [1]
        },
        //这些钩子和v-direct render 相应情况都是一致的
        watch: {
            //数组深度监听和浅度监听一样的
            todo(_new, _old) {
                console.log(_new)
            }
        },
        computed: {
            todo1() {
                console.log(`computed执行`)
                return this.todo
            }
        },
        beforeUpdate() {
            console.log('beforeUpdate')
            this.$nextTick().then(res => {
                console.log('$nextTick')
            })
        },
        updated() {
            console.log('updated')
        },

    })

</script>


<style>
    .btn-success {
        background: greenyellow;
    }

</style>