<meta charset="utf-8">
<script src="https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.js"></script>
<script src="https://cdn.bootcss.com/vuex/3.0.1/vuex.js"></script>
<script src="https://cdn.bootcss.com/axios/0.18.0/axios.min.js"></script>
<script src="https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js"></script>


<div id="app">

    <span v-for="item in todo">{{item}} </span>
    <hr>
    {{todo.a}} {{todo.b}}
    <hr>
    {{todo}}
    <hr>
  <!-- 和上面没差别 一样监视不了,不因渲染obj.key而变化,render默认还是监听obj-->
    {{todoComputed}}
    <hr>

<!-- 默认可以监听到vm.obj的原有键值变化,监听不到新加键值---------------------------------------------------------------   -->
    <!--    可以监听到添加todo.a赋值-->
    <button @click="todo.a=10" class="btn-success">todo.a=10</button>

    <!--    不能监听到添加新键值-->
    <button @click="todo.b=2">todo.b=2</button>


    <!--    不能监听到assign添加新键值-->
    <button @click="Object.assign(todo,{b:2})">Object.assign(todo,{b:2})</button>
    <!--      //原始键更新了,顺带把新键值也更新了-->
    <button @click="Object.assign(todo,{a:10,b:2})" class="btn-success">Object.assign(todo,{a:10,b:2})</button>


    <!--    用set可以监听到添加新键值---------------------------------------------------------------------------------------------->
    <button @click="$set(todo,'c',2)" class="btn-success">$set(todo,'c',2)"</button>


    <!--    更改对象的内存地址----------------------------------------------------------------------------------------->
    <button @click="todo={a:100,b:200}" class="btn-success">todo={a:10,b:20}</button>

</div>


<script>


    const vm = new Vue({
        el: '#app',

        data: {

            todo: {a: 1}
        },
        //这些钩子和v-direct render 相应情况都是一致的
        watch: {

            /*  todo(_new, _old) {
                  console.log(_new)
              },*/
            todo: {
                //watch比较弱,必须深度监听才能监听到对象的原键值的变化
                deep: true,
                immediate: true,
                handler(_new, _old) {
                    console.log(_new)
                }
            },

        },
        computed: {
            todoComputed() {
                console.log(`computed执行`)
                return this.todo
            }
        },

        beforeUpdate() {
            console.log('beforeUpdate')
            this.$nextTick().then(res => {
                console.log('$nextTick')
            })
        },
        updated() {
            console.log('updated')
        },

    })

</script>

<style>

    .btn-success {
        background: greenyellow;
    }

</style>
