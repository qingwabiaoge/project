# 函数的调用
-------------------------

>被调用时执行,

>函数后面的()表示运行


> 对于同一个变量fn,变量fn只有一个内存地址

> 复制到任何地方只是复制了一个内存地址,函数堆内存没有改变,还是同一个函数,this和参数对于不同的调用会赋不同值

>__运行:内存地址f,f()__

自执行

       (function () {
                    var i=0
                    i += 1
                    i *=5
                    console.log(i)
                })()

赋值执行2

         function f() {
                            var i=0
                            i += 1
                            i *=5
                            console.log(i)
                        }
                 f()
赋值执行3-递归


采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

```
var print = function x(){
  console.log(typeof x);
};

x
// ReferenceError: x is not defined

print()
// function
````
```
//无限递归
 var print = function fn() {
        console.log('1')
        fn()
    };
    print()

```


赋值给f后f()执行

```

        var f=function () {
                    var i=0
                    i += 1
                    i *=5
                    console.log(i)
                }
         f()

```
高阶回调


````
    var i = 1
    var fn = //2函数地址复制给fn
        function () {//1函数声明 自由变量在哪个作用域取值在声明时间已经确定
        console.log(i)
    }
    const fn2 = function () {
        var i = 2
        var f = fn //3 fn存的地址复制给f,并没有重新声明函数
        f()//调到fn里执行,确定自由变量的值
    }
    fn2()

````
函数做参数

```

var i = 1

function fn() {//1函数声明 自由变量在哪个作用域取值在声明时间已经确定
    console.log(i)
}

function fn2(f) {
    var i = 2
    f()//调到fn里执行,确定自由变量的值
}

fn2(fn)

```


赋值执行5-闭包


````
    var i = 1
    var fn = function () {
        var i = 2

        function fn2() {
            console.log(i)
        }

        return fn2
    }
    var f = fn() //fn2的地址复制给f
    f()//2
````



Object.fn()

```
     obj={fn:function () {
            console.log(this)
        }}
    console.log(obj.fn)//fn
    obj.fn()//obj
```
```
 i = 1
    const fn = function () {
        console.log(this)
        console.log(i)
    }
    obj = {a: 1, fn}
    fn()  // window,1
    obj.fn()//obj,1
```

arry

    arr=[function () {
        console.log(1)
    },2]
        arr[0]()
require'xxx'()
     
     moudle.exports=route(){.....}
     -------------------------  
     const route=require('route')()




指定this的值运行

      fn.call(obj,a,b)

指定参数运行

```

 var f=function (i) {
                
                i += 1
                i *=5
                console.log(i)
            }
     f(1)

```

在指定时间执行


      setTimeout(function(){},3000)  






# 函数调用才会建立函数上下文栈

 打开页面代码顺序(包含import里的代码)调用执行(执行运算符|函数运行表达式),只有函数调用,才会建立函数上下文栈,运行局部作用域的代码

# 函数调用才会执行
### 自动调用

```
function fn{}

fn()
```
### 事件调用

2. 事件驱动(onclik事件触发运行,路由切换事件触发构造函数运行)

3. __异步组件:__切换路由 会触发webpack下载代码事件和异步运行vue构造函数




