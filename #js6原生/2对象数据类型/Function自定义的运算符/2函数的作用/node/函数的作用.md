# 第一公民作为值使用

### 函数声明赋值给变量

```js
    //1.函数的定义
    function sum1(a1,b1){
        return a1+b1;
    }
    sum1.age = 100;
    console.log(sum1(1,1));//2
    console.log( sum1.age )


    var sum2 = function(a1,b1){
        return a1+b1;
    };
    console.log(sum2(1,1));//2
    console.log(sum2)



    var sum3 = new Function("a1,b1","return a1+b1;");
    console.log({sum3})
    sum3.age = 100;
    console.log(sum3(1,1));//2
    console.log(sum3.age);//100

```

es6语法的错觉

```js
    data = {
        a: 1,
       function  () {
            console.log(123)

        }
    }


//上面等价于

    data = {
        a: 1,
       function: function  () {
            console.log(123)

        }
    }

```

### 所有属性(真实数据结构) in

```js
  const Fn = function () {
    console.log(Fn.arguments)
    console.log(Fn.arguments.callee)
  }
  Fn.staticMethod1 = function () {
  }
  Fn.staticMethod2 = function () {
  }
  console.log({Fn})
```



![1567864824530](img/1567864824530.png)



##### Function.protype

```javascript
  //1.原型属性Function.prototype---------------
   console.log({'Function.protype': Object.getPrototypeOf(fn)})
  /*{ 
    apply: ? apply()
    arguments: (...)
    bind: ? bind()
    call: ? call()
    caller: (...)
    constructor: ? Function()
    length: 0
    name: ""
    toString: ? toString()
    Symbol(Symbol.hasInstance): ? [Symbol.hasInstance]()
    get arguments: ? ()
    set arguments: ? ()
    get caller: ? ()
    set caller: ? ()
    }*/

```

##### OwnProperty

```js
  //2.Own属性,Function构造生成---------------------    
    console.log(Object.getOwnPropertyNames(Fn))//(6)["length", "name", "arguments", "caller", "prototype","staticMethod1","staticMethod2"]


```

##### keys

```js
    //3.可枚举属性:静态变量,静态方法--------------------
     console.log(Object.keys(Fn)) //[staticMethod1,staticMethod2]

     //for..in还能枚举出 

    for (item in f) {
        console.log(item) //staticMethod1,staticMethod2

    }
```

### 作为参数

##### 作为promise初始化的参数

```javascript
new Promise((resolve,reject)=>{resolve(1)})
```

##### 作为回调函数的参数

```
Array.sort((a,b)=>a-b)
```



# fn()多次运行fn定义式的代码段

1. 运行特定代码段
2. 多次运行

自执行

```
   (function () {
                var i=0
                i += 1
                i *=5
                console.log(i)
            })()
```

声明函数,然后执行区别于声明变量,父作用域上下文栈准备阶段 f已经赋值

```
     function f() {
                        var i=0
                        i += 1
                        i *=5
                        console.log(i)
                    }
             f()
```

赋值执行-递归

采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

```js
var print = function x(){
  console.log(typeof x);
};

console.log(x)
// ReferenceError: x is not defined

print()
// function
```

```js
//无限递归
 var print = function fn() {
        console.log('1')
        fn()
    };
    print()

```

赋值给f后f()执行

```js
        var f=function () {
                    var i=0
                    i += 1
                    i *=5
                    console.log(i)
                }
         f()

```

回调参数 函数做参数

```js
function fn2(f) {
    var i = 2
    f()//调到fn里执行,确定argument和this
}


var i = 1
fn2(function fn(arg) {//1函数声明 自由变量在哪个作用域取值在声明时间已经确定
    console.log(i)
    console.log(arg)//undefind
})

```

赋值执行5-闭包

```js
    var i = 1
    var fn = function () {
        var i = 2

        function fn2() {
            console.log(i)
        }

        return fn2
    }
    var f = fn() //fn2的地址复制给f
    f()//2
```

Object.fn() 先计算出地址再运行

```js
     obj={fn:function () {
            console.log(this)
        }}
  
    obj.fn()//obj和fn和()一起计算时,this===obj
```

```js
    cosnt obj = {a: 1}
     obj.fn = function () {
        console.log(this)
    }
   
    const f=obj.fn  //obj.fn先计算得到了内存地址
    f() //f和()计算,this===windows
```

arry

```
arr=[function () {
    console.log(1)
},2]
    arr[0]()
```

require'xxx'()
     

```
 moudle.exports=route(){.....}
 -------------------------  
 const route=require('route')()
```

指定this的值运行

```
  fn.call(obj,a,b)
```

指定参数运行

```
 var f=function (i) {
                
                i += 1
                i *=5
                console.log(i)
            }
     f(1)

```

==这里很特殊==

```
    function fn() {
        console.log(arguments) //[1,2]
    }

    fn(1,2)
```

在指定时间执行

```
  setTimeout(function(){},3000)  
```

异步事件调用执行

```
 事件驱动(onclik事件触发运行)
 vue-router路由切换钩子触发构造函数运行,造成了局部组件
 vue异步组件:切换路由 会触发webpack下载代码事件和异步运行vue构造函数
```

### 参数个数模拟重载

```js
  function fn(i, m) {
    if (arguments.length === 1) {
      return 1
    } else if (arguments.length === 2) {
      return 2
    } else {
      return 0
    }

  }

  console.log(fn(), fn(1), fn(1, 2))

```



# 计算部分:  函数是可以和()计算的特殊对象

### return 设置返回值

1. 制造新指令fn()(返回任意值) 
2. 闭包(返回函数)
3. 柯利化函数(返回函数)
4. new Fn(p1,px)(返回Fn类型的对象)

```javascript
//1.直接生成对象,无构造函数参与
obj={a:1,b:2}
obj=new Object({a:1,b:2})
//2.构造函数版生成对象,构造函数参与

function Fn(a,b) {
  this.a=a;
  this.b=b
}
Fn.prototype={c:3} //固定部分

obj=new Fn()
```

# 函数作用域隔离变量

函数作用域

# 函数作用域里的变量赋值取值

### 自由变量

1. 声明变量
2. import引入局部作用域的变量做全局变量

### 参数

##### 取值参数的值

- 函数调用,`arguments`
- 跨作用域回调传值.

##### 读取对象类型的参数,扩展对象类型

```javascript
const ctx={a:1}

function f(ctx) {
    ctx.b=2
}
f(ctx)


```

### this

##### 为this赋值

###### obj.fn(  )

this===0bj

###### 指定this的值

call apply

###### 构造函数的this赋值

new Fn() ,本质 Fn().call(new Object),新建一个对象改变这个对象的键值

###### 无法为this赋值的

默认设置为window,严格模式为undefined

##### 取得this的key

```
this.$store
this.$axios
```

