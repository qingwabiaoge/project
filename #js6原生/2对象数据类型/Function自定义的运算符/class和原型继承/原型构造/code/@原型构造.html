<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    /*此处为实例化对象封装了若干属性和函数*/
    function Person(name, age) {
        this.name = name
        this.age = age
        this.sayName = function () {
            console.log('我的名字叫:' + this.name);
        }


    }


    // 更改构造函数: 更改构造函数一定放到最前面,因为改变了变量Person内存地址

    Person = function (name, age) {
        this.name = name + 1111
        this.age = age + 100
        this.sayName = function () {
            console.log('我的名字叫:' + this.name + 1111);
        }

        return 10
    }


    //为封装一些原型方法
    Person.prototype = {
        //protype.sayName被构造里的sayName覆盖
        sayName() {
            console.log('my name:' + this.name);
            console.log('protype.sayName(){}的this', this)
        },
        addage() {
            this.age++ //通过this改变age

        },
        returnMoutAge() {
            return this.age - 1
        }

    }


    /*扩展静态函数和静态变量*/
    Person.nameUpperCase = function (i) {
        console.log(i.toUpperCase())
    }
    Person.title = '静态函数类'


    //扩展原型方法
    Person.prototype.$store = {
        name: 2,
        setName(name) {
            console.log(this)
            this.name = name
        }
    }


    //new 创立新实例 构造函数运行在这个对象上 Person.call(obj, 'xiaohong', 12)
    xiaoli = new Person('xiaoli', 11, "设计师")
    xiaoli.sayName()
    xiaoli.addage()
    xiaoli.$store.setName('小莉')
    console.log(xiaoli)


    //不改变实例xiaoli的属性 函数有返回值,类似arr的迭代函数
    const i = xiaoli.returnMoutAge()
    console.log(i)


    //运行静态函数
    Person.nameUpperCase('abc')


    //当普通函数使用 ,添加变量到了window--------------------------------------------------------------------------------------------
   const m= Person('xiaowang', 12)
    console.log(m,name, age)


    //模拟new new都做了什么---------------------------------------------------------------------------------------------------------

    //因为这部所以对象的都是构造函数建立出来的
    var obj = new Object();
    obj.__proto__ = Person.prototype;


    // 改变obj的值
    var res = Person.call(obj, 'xiaohong', 12)


    /*  判断Person的返回值 若返回值为对象 person=构造函数的返回值,
       变成了类似另外一种函数了
       function f() {
           return {a,b}
       }
       */
    if (typeof res === Object) {
        person = res
    }
    //如果返回值为undefine或者基础变量 person=被构造函数改变的对象obj
    else {
        person = obj

    }
    console.log(person)

</script>
</body>
</html>
