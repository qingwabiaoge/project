




# 类是概念

类:一类事物,比如数字类 , 字符串类, 对象类->数组类,动物类 ->狗类


类:同类型 同class -> 定义构造函数Person

实例化对象: const xiaoli=new Person()

实例化对象属于类型: xiaoli是Person类型的



# 类的三要素
### 1.   封装

函数封装, 私有变量不允许实例化对象访问,静态函数不允许子类继承

### 2.   继承和extend

本质修改代码,对原始的蓝图进行修改,产生新型号汽车的蓝图,用于生成新的汽车

```javascript
class StangtanaCar1000{
//一些代码
}

class StangtanaCar2000 extends StangtanaCar1000{
   //另外一些代码
    
}

```
### 3.多态


##### js语言最直观的本事就是多态

```javascript

var  a  =  5;
console.log(a);
 
a="str";
 
console.log(a)
```

一个函数适用不同的类 

因为js是动态语言,js天生多态

js在计算时间才确定变量类型

静态语言的函数规定的有参数类型,只有规定的参数类型才可以用此函数


##### 定义

多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结
果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的
反馈。

##### 作用:

一个函数用于不同类型的对象,强语言需要验证类型才能使用函数,而弱类型不用天生就是多态

##### 本质是是什么和做什么分开:


是什么:类

做什么:函数




###### 分离:

```

    var googleMap = {
        show: function () {
            console.log('开始渲染谷歌地图');
        }
    };
    var renderMap = function () {
        googleMap.show();
    };
    renderMap(); // 输出：开始渲染谷歌地图

```
###### 多态:一个函数使用不同的对象
 
 
```
var googleMap = {
    show: function(){
        console.log( '开始渲染谷歌地图' );
    }
};
var baiduMap = {
    show: function(){
        console.log( '开始渲染百度地图' );
    }
};
var renderMap = function( type ){
    if ( type === 'google' ){
        googleMap.show();
    }else if ( type === 'baidu' ){
        baiduMap.show();
    }
};
renderMap( 'google' ); // 输出：开始渲染谷歌地图
renderMap( 'baidu' ); // 输出：开始渲染百度地图


```
##### 基本概念

多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的引用，来调用在不同子类中实现的方法。

```javascript
// Master类 
function Master(name){ 
    this.nam=name; 
    //方法[给动物喂食物] 
} 
//原型法添加成员函数 
Master.prototype.feed=function (animal,food){ 
    window.alert("给"+animal.name+" 喂"+ food.name); 
} 
function Food(name){ 
    this.name=name; 
} 
//鱼类 
function Fish(name){ 
    this.food=Food; 
    this.food(name); 
} 
//骨头 
function Bone(name){ 
    this.food=Food; 
    this.food(name); 
} 
function Peach(name){ 
    this.food=Food; 
    this.food(name); 
} 
//动物类 
function Animal(name){ 
    this.name=name; 
} 
//猫猫 
function Cat(name){ 
    this.animal=Animal; 
    this.animal(name); 
} 
//狗狗 
function Dog(name){ 
    this.animal=Animal; 
    this.animal(name); 
} 
//猴子 
function Monkey(name){ 
    this.animal=Animal; 
    this.animal(name); 
} 
var cat=new Cat("猫"); 
var fish=new Fish("鱼"); 

var dog=new Dog("狗"); 
var bone=new Bone("骨头"); 

var monkey=new Monkey("猴"); 
var peach=new Peach("桃"); 

//创建一个主人 
var master=new Master("zs"); 
master.feed(dog,bone); 
master.feed(cat,fish); 
master.feed(monkey,peach);


```
同一个实现接口，使用不同的实例而执行不同的操作。比如：打印机可以看作是父类，黑白打印机、彩色打印机是他的两个子类。父类打印机中的方法“打印”在每个子类中有各自不同的实现方式，比如对黑白打印机执行打印操作后，打印效果是黑白的，而对彩色打印机进行打印操作后，打印效果是彩色的。




同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。（某某百科）
本质上也就如题主说描述的“将‘做什么’和‘谁去做以及怎样去做’分开”，归根结底就是先消除不同对象的耦合关系。

```javascript
//使用es6 class简化代码
class Parent {
    sayName() {
        console.log('Parent');
    }
}
class Child extends Parent{
    sayName() {
        console.log('Child');
    }
}
var child = new Child();
child.sayName(); // 'Child'

var parent = new Parent();
parent.sayName(); // 'Parent'

```



# 类的实例化

### 本质是copy代码

 像某个型号汽车建设蓝图,生产这个型号的汽车蓝图
 
```javascript
  const car1=new SangtanaCar001()
```


### js类生成实例化对象也可以扩展

因为js是一种动态语言,计算时间才确定类型





# 静态函数和实例方法

静态函数适合所有实例用的工具函数
```javascript
Dog.Create({id:1})
Dog.find({id:1})
Dog.remove({id:2})
dog.update({id:3})
```


实例方法适合个例用的方法
```javascript

instance.showInfo

```

实例化对象
```javascript
const dog=new Dog({id:5})
```



# 原型构造


### 构造函数和对象的关系

Object Array等构造器是函数,函数创造对象
fn instaceof Objcet===true,所以函数实例fn是对象

### 函数辅助构造对象

##### {a:1,b:2}


{a:1,b:2}等价于new object({a:1,b:2}) ,建立对象没有Fn构造函数的辅助,用函数生成键值对


##### new Fn(i,m)

new Fn(i,m)等价于Fn(i,m).call(new Objcet())

有构造函数辅助生成对象

可以设置函数参数

### 函数属于对象类型

```
funcion fn(a,b){

return a+b
}

fn.a=1
fn.b=2

```

```
const fn=new Function('a', 'b', 'return a + b');

```

```
fn instaceof Objcet===true
```


# 构造函数未传参的参数和普通函数一样默认undefine

vue对象的默认属性的值undefined构造函数调用new button(),实参传值给形参未赋值的形参为undefine


### js弱类型 构造函数的键值对一切可变

![](./1.png)

### 继承于原型prototype ,并非被继承于构造函数

![](./2.png)

```
例如 vm=new Vue({})

vm 继承于Vue.prototype(这是一个对象),Vue只是一个辅助构造函数,携带了静态函数和静态属性

Vue.prototype是一个对象继承于Object.prototype,Object只是一个辅助构造函数

这些辅助构造函数Object,Vue继承于 Function.prototype,Function.prototype继承于Object.prototype

```

### 继承关系

![](3.png)





# class封装
class的本质是创造一类的若干对象的构造函数,类是构造函数的语法糖

```
 Class={
    staticFn:()=>{...}
    protorype:{
               instaceFn(){}
               }


   }

Class.staticFn:()

Class.protorype.instaceFn()
```
```javascript

 class Point {
        static staticFn() {
            console.log('staticFn')
        }

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        get value() {
            console.log('Getting the current value!');
            return this.x;
        }

        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }
    }

    const point = new Point(1, 2)

    console.log(point)

    class Point_extend extends Point {


        cs() {
            console.log('cs')
        }
    }

    //类能继承静态函数
    Point_extend.staticFn()

    const point_extend = new Point_extend(10, 20)

    console.log(point_extend)

```


