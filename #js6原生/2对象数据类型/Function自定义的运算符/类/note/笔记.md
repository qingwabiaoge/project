 <meta charset="UTF-8" />




# 类是概念

类:一类事物,比如数字类 , 字符串类, 对象类->数组类,动物类 ->狗类


类:同类型 同class -> 定义构造函数Person

实例化对象: const xiaoli=new Person()

实例化对象属于类型: xiaoli是Person类型的



# 类的三要素
### 1.   封装

函数封装, 私有变量不允许实例化对象访问,静态函数不允许子类继承

### 2.   继承和extend

本质修改代码,对原始的蓝图进行修改,产生新型号汽车的蓝图,用于生成新的汽车

```javascript
class StangtanaCar1000{
//一些代码
}

class StangtanaCar2000 extends StangtanaCar1000{
   //另外一些代码
    
}

```
### 3.多态


##### 基本概念

一个函数适用于不同对象，返回不同的值

同一个实现接口，使用不同的实例而执行不同的操作。比如：打印机可以看作是父类，黑白打印机、彩色打印机是他的两个子类。父类打印机中的方法“打印”在每个子类中有各自不同的实现方式，比如对黑白打印机执行打印操作后，打印效果是黑白的，而对彩色打印机进行打印操作后，打印效果是彩色的。

同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。（某某百科）
本质上也就如题主说描述的“将‘做什么’和‘谁去做以及怎样去做’分开”，归根结底就是先消除不同对象的耦合关系。

##### 多态超类实现实例：

一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的引用，来调用在不同子类中实现的方法。

```javascript
// Master类 
function Master(name){ 
    this.nam=name; 
    //方法[给动物喂食物] 
} 
//原型法添加成员函数 
Master.prototype.feed=function (animal,food){ 
    window.alert("给"+animal.name+" 喂"+ food.name); 
} 
function Food(name){ 
    this.name=name; 
} 
//鱼类 
function Fish(name){ 
    this.food=Food; 
    this.food(name); 
} 
//骨头 
function Bone(name){ 
    this.food=Food; 
    this.food(name); 
} 
function Peach(name){ 
    this.food=Food; 
    this.food(name); 
} 
//动物类 
function Animal(name){ 
    this.name=name; 
} 
//猫猫 
function Cat(name){ 
    this.animal=Animal; 
    this.animal(name); 
} 
//狗狗 
function Dog(name){ 
    this.animal=Animal; 
    this.animal(name); 
} 
//猴子 
function Monkey(name){ 
    this.animal=Animal; 
    this.animal(name); 
} 
var cat=new Cat("猫"); 
var fish=new Fish("鱼"); 

var dog=new Dog("狗"); 
var bone=new Bone("骨头"); 

var monkey=new Monkey("猴"); 
var peach=new Peach("桃"); 

//创建一个主人 
var master=new Master("zs"); 
master.feed(dog,bone); 
master.feed(cat,fish); 
master.feed(monkey,peach);


```


```javascript
//使用es6 class简化代码
class Parent {
    sayName() {
        console.log('Parent');
    }
}
class Child extends Parent{
    sayName() {
        console.log('Child');
    }
}
var child = new Child();
child.sayName(); // 'Child'

var parent = new Parent();
parent.sayName(); // 'Parent'

```



##### js语言最直观的本事就是多态

```javascript

var  a  =  5;
console.log(a);
 
a="str";
 
console.log(a)
```

一个函数适用不同的类 

因为js是动态语言,js天生多态

js在计算时间才确定变量类型

静态语言的函数规定的有参数类型,只有规定的参数类型才可以用此函数




##### 是一种解耦机制是是什么和做什么分开:


是什么:类

做什么:函数




###### 分离:

```

    var googleMap = {
        show: function () {
            console.log('开始渲染谷歌地图');
        }
    };
    var renderMap = function () {
        googleMap.show();
    };
    renderMap(); // 输出：开始渲染谷歌地图

```
###### 多态:一个函数使用不同的对象
 
 
```
var googleMap = {
    show: function(){
        console.log( '开始渲染谷歌地图' );
    }
};
var baiduMap = {
    show: function(){
        console.log( '开始渲染百度地图' );
    }
};
var renderMap = function( type ){
    if ( type === 'google' ){
        googleMap.show();
    }else if ( type === 'baidu' ){
        baiduMap.show();
    }
};
renderMap( 'google' ); // 输出：开始渲染谷歌地图
renderMap( 'baidu' ); // 输出：开始渲染百度地图


```


# 类的实例化

### 返回一类事物的一个实例

 像某个型号汽车建设蓝图,生产这个型号的汽车蓝图
 
```javascript
  const car1=new SangtanaCar001()
```


### js类生成实例化对象也可以扩展

因为js是一种动态语言,计算时间才确定类型





# 静态函数

静态函数适合所有实例用的工具函数
```javascript
Dog.Create({id:1})
Dog.find({id:1})
Dog.remove({id:2})
dog.update({id:3})
```

# 实例化对象

实例化对象
```javascript
const dog=new Dog({id:5})
```
实例方法适合个例用的方法
```javascript

instance.showInfo

```


# 原型构造

### 作用:控制参数返回对象

```javascript
//1.直接生成对象,无构造函数参与
obj={a:1,b:2}
obj=new Object({a:1,b:2})
//2.构造函数版生成对象,构造函数参与

function Fn(a,b) {
  this.a=a;
  this.b=b
}
Fn.prototype={c:3} //固定部分

obj=new Fn()
```

### 构造函数和对象的关系


##### new Fn() 生成新的对象实例

```javascript 1.8

    //模拟new new都做了什么
    var obj = new Object();
    obj.__proto__ = Person.prototype;
    var res = Person.call(obj, 'xiaohong', 12)// 改变obj的值

    if (typeof res === Object) {//判断function的返回值 若返回值为对象 person就为这个返回值了 构造函数废了
        person = res
    }
    else { //如果返回值为undefine或者基础变量 构造函数成功
        person = obj

    }


```

##### 函数属于对象类型

```
funcion fn(a,b){

return a+b
}

fn.a=1
fn.b=2

```

```
const fn=new Function('a', 'b', 'return a + b');

```

```
fn instaceof Objcet===true
```


### 构造函数未传参的参数和普通函数一样默认undefine

vue对象的默认属性的值undefined构造函数调用new button(),实参传值给形参未赋值的形参为undefine


### js弱类型 构造函数的键值对一切可变

![](./1.png)







### 原型链

![](3.png)
# class封装
class的本质是创造一类的若干对象的构造函数,类是构造函数的语法糖

```
 Class={
    staticFn:()=>{...}
    protorype:{
               instaceFn(){}
               }


   }

Class.staticFn:()

Class.protorype.instaceFn()
```
```javascript

 class Point {
        static staticFn() {
            console.log('staticFn')
        }

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        get value() {
            console.log('Getting the current value!');
            return this.x;
        }

        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }
    }

    const point = new Point(1, 2)

    console.log(point)

    class Point_extend extends Point {


        cs() {
            console.log('cs')
        }
    }

    //类能继承静态函数
    Point_extend.staticFn()

    const point_extend = new Point_extend(10, 20)

    console.log(point_extend)

```


