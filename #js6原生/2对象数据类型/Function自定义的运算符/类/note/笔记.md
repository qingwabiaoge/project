




# 类是概念

类:一类事物,比如数字类 , 字符串类, 对象类->数组类,动物类 ->狗类


类:同类型 同class -> 定义构造函数Person

实例化对象: const xiaoli=new Person()

实例化对象属于类型: xiaoli是Person类型的



# 类的三要素
### 1.   封装

函数封装, 私有变量不允许实例化对象访问,静态函数不允许子类继承

### 2.   继承和extend

本质修改代码,对原始的蓝图进行修改,产生新型号汽车的蓝图,用于生成新的汽车

```javascript
class StangtanaCar1000{
//一些代码
}

class StangtanaCar2000 extends StangtanaCar1000{
   //另外一些代码
    
}

```
### 3.多态

一个函数适用不同的类 

因为js是动态语言,js天生多态

js在计算时间才确定变量类型

静态语言的函数规定的有参数类型,只有规定的参数类型才可以用此函数


##### 定义

多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结
果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的
反馈。

##### 作用:

一个函数用于不同类型的对象,强语言需要验证类型才能使用函数,而弱类型不用天生就是多态

##### 本质是是什么和做什么分开:


是什么:类

做什么:函数




###### 分离:

```

    var googleMap = {
        show: function () {
            console.log('开始渲染谷歌地图');
        }
    };
    var renderMap = function () {
        googleMap.show();
    };
    renderMap(); // 输出：开始渲染谷歌地图

```
###### 多态:一个函数使用不同的对象
 
 
```
var googleMap = {
    show: function(){
        console.log( '开始渲染谷歌地图' );
    }
};
var baiduMap = {
    show: function(){
        console.log( '开始渲染百度地图' );
    }
};
var renderMap = function( type ){
    if ( type === 'google' ){
        googleMap.show();
    }else if ( type === 'baidu' ){
        baiduMap.show();
    }
};
renderMap( 'google' ); // 输出：开始渲染谷歌地图
renderMap( 'baidu' ); // 输出：开始渲染百度地图


```



# 类的实例化

### 本质是copy代码

 像某个型号汽车建设蓝图,生产这个型号的汽车蓝图
 
```javascript
  const car1=new SangtanaCar001()
```


### js类生成实例化对象也可以扩展

因为js是一种动态语言,计算时间才确定类型





# 静态函数和实例方法

静态函数适合所有实例用的工具函数
```javascript
Dog.Create({id:1})
Dog.find({id:1})
Dog.remove({id:2})
dog.update({id:3})
```


实例方法适合个例用的方法
```javascript

instance.showInfo

```

实例化对象
```javascript
const dog=new Dog({id:5})
```



# 原型构造


### 构造函数和对象的关系

Object Array等构造器是函数,函数创造对象
fn instaceof Objcet===true,所以函数实例fn是对象

### 函数辅助构造对象

##### {a:1,b:2}


{a:1,b:2}等价于new object({a:1,b:2}) ,建立对象没有Fn构造函数的辅助,用函数生成键值对


##### new Fn(i,m)

new Fn(i,m)等价于Fn(i,m).call(new Objcet())

有构造函数辅助生成对象

可以设置函数参数

### 函数属于对象类型

```
funcion fn(a,b){

return a+b
}

fn.a=1
fn.b=2

```

```
const fn=new Function('a', 'b', 'return a + b');

```

```
fn instaceof Objcet===true
```


# 构造函数未传参的参数和普通函数一样默认undefine

vue对象的默认属性的值undefined构造函数调用new button(),实参传值给形参未赋值的形参为undefine


### js弱类型 构造函数的键值对一切可变

![](./1.png)

### 继承于原型prototype ,并非被继承于构造函数

![](./2.png)

```
例如 vm=new Vue({})

vm 继承于Vue.prototype(这是一个对象),Vue只是一个辅助构造函数,携带了静态函数和静态属性

Vue.prototype是一个对象继承于Object.prototype,Object只是一个辅助构造函数

这些辅助构造函数Object,Vue继承于 Function.prototype,Function.prototype继承于Object.prototype

```

### 继承关系

![](3.png)





# class封装
class的本质是创造一类的若干对象的构造函数,类是构造函数的语法糖

```
 Class={
    staticFn:()=>{...}
    protorype:{
               instaceFn(){}
               }


   }

Class.staticFn:()

Class.protorype.instaceFn()
```
```javascript

 class Point {
        static staticFn() {
            console.log('staticFn')
        }

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        get value() {
            console.log('Getting the current value!');
            return this.x;
        }

        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }
    }

    const point = new Point(1, 2)

    console.log(point)

    class Point_extend extends Point {


        cs() {
            console.log('cs')
        }
    }

    //类能继承静态函数
    Point_extend.staticFn()

    const point_extend = new Point_extend(10, 20)

    console.log(point_extend)

```


