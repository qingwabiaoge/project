# 字面量


### 修饰符:
/m多行匹配 [英]multi- :多个

/g [英]globe

/i 对大小写不敏感


##### 对match适用  (返回匹配的字符串放到数组里)

str.match(reg)

````
  var str = 'run runoob runooob runoooooob';

 reg=/runo*/g   

console.log(str.match(reg)); //[ 'run', 'runoo', 'runooo', 'runoooooo']

````

多行匹配

```javascript

    {
    const str="This is an\n antzone good";
    const reg=/an$/;
    console.log(str.match(reg));   //null

    }
    {

        const str="This is an\n antzone good";
        const reg=/an$/m;
        console.log(str.match(reg));//[...........]
    }

    {
        const reg = /^b/;
        const str = 'test\nbbs';
       console.log(str.match(reg)) //null

    }

    {
        const reg = /^b/m;
        const str = 'test\nbbs';
        console.log(str.match(reg))//[...........]


    }

```



##### 对replace适用(返回被替换后的字符串)
str.repalce(reg,'xxx')
```
  var str='秦石磊是个好人,秦石磊是个好男人'
    reg1=/(好)/
    reg2=/(好)/g
    console.log(str.replace(reg1,'坏'))
    console.log(str.replace(reg2,'坏'))


```
str.repalce(reg,fn(item){})
```
    function replaceReg(reg, str) {
        return str.replace(reg, function (item) {
            return `<a href="item">${item}</a>`;
        })
    }

    var reg = /http:\/\/[\w-]*(\.[\w-]*)+/ig;
    var str = '将一个用户输入的一段文字中的url替换成可以点击的link地址。测试一下：http://www.ablanxue.com紧接着中文，还有    http://www.baidu.com';
    document.write(replaceReg(reg, str));

```


##### str.search(reg)&indexOf('str')(返回第一个匹配的字符串的索引 所以只有  i m适用)

```
   var str = '1111shi,leiqin11qin111,'
    const reg = /(qin|shi)/
    console.log(str.search(reg)) //4
    console.log(str.indexOf('qin')) //11
    console.log(str.lastIndexOf('qin')) //6
    
```
修饰符

```
  const reg = /(ab){2}$/mi
    const str = 'Abab\n1111'
    console.log(str.search(reg))

```



##### 对正则方法test(str) exec(str)适用,因为正则方法值匹配第一个 所以只有  i m适用



```
  const reg = /ab$/mi
    const str = 'Ab\n1111'
    console.log(reg.test(str)) //true`
    console.log(reg.exec(str))//["Ab"]
```


### \  转意字符(单字符)
```
 . 代表任意字符
\. 表示真实的.

\n   换行  ~next

\t   制表 tab制表符

\r   回车  ~enter

\s   空格  ~space

\S   非空格

\d   数字1位  ~[英]digit

\D   非数字

\w   字符 ( 字母 ，数字，下划线_ )   //[英]word

\W   非字符

```



###  [-] 自定义匹配范围 (单字符) [^ ]排除后的范围匹配

[a-zA-z]匹配英文大小写

[  ^ ]表示排除  [^ \s]

[0-3]匹配0，1，2，3

[^ 0-3 ]匹配 4，5，6，7，8，9

[0-9]* 匹配数字（注意后面有 *，可以为空）

[0-9]+ 匹配数字（注意后面有 +，不可以为空）






### 次数类* +  ?  {}
##### {}
{}一般用来表示匹配的长度，

\s{3} 表示匹配三个空格，

\s{1,3}表示匹配一到三个空格。

o{,3}

(a|b){3,}


##### ?
 runo? 可以匹配 run 或者 runo，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。**

##### +
 runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。
##### *
 runoo * b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。





### 匹配位置$ ^



匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。




```
var str = 'my name is shilei'

const reg = /lei$/

console.log(reg.test(str)) //true

console.log(reg.exec(str)) //['lei']

```




### ()的作用: 分组+捕获, 分组+不捕获

##### 分组

###### 多字符
一个分组中可以像上面这样有一个具体的表达式，这样可以优雅地表达一个重复的字符串

```
/(ha){3}/
/hahaha/

```
###### 或操作

或操作（|）或操作

```
（a|b）匹配a或者b
```


##### ()捕获

###### 对reg.test()的影响: 

可以用括号分组

###### 对reg.exec()的影响:
 
捕获到reg.exec('xxx')[1],
   
可以通过RegExp.$1访问,

```
    const reg = /(doubi) is a doubi/
    console.log(reg.exec('doubi is a doubi'))// [0: "doubi is a doubi" 1: "doubi"]
    console.log(RegExp.$1 )//doubi,记忆窍门:和$1===reg.exec('xxx')[1}
```
在表达式里通过/1访问
   
```

   const reg = /(doubi) is a \1/
    console.log(reg.exec('doubi is a doubi'))// [0: "doubi is a doubi" 1: "doubi"]
    console.log(RegExp.$1 )//doubi

```

##### (?)非捕获

###### 非捕获(?:)

对reg.test()的影响: 可以用括号分组

对reg.exec()的影响: 括号部分不捕获


```

const reg = /kid is (?:doubi)*/

const str='kid is  doubidoubidoubi'
console.log(reg.test(str))// true
console.log(reg.exec(str))// [0:kid is]


```

###### 非捕获前瞻(?=)  

####### 前瞻的含义是:

对reg.test()的影响:往前看一下是否有相等的值,有则返回true

对reg.exec()的影响:不捕获

```
   const reg = /kid is a (?=doubi)/
   console.log(reg.exec('kid is a doubi'))// [0:kid is a] 
```


```
//开头就前瞻
const reg = /^(?=haha)/
const str = "hahahamimimi"


console.log(reg.test(str))//true
```  

###### 非捕获前瞻否定(?!)   

####### 前瞻的含义是:

对reg.test()的影响: 往前看一下是否有不相等的值,有则返回true

对reg.exec()的影响: 不捕获


```

     const reg = /kid is a (?!doubi)/

    console.log(reg.test('kid is a doubi')) // false
    console.log(reg.test('kid is a shabi')) // true
    console.log(reg.exec('kid is a doubi'))// null
    console.log(reg.exec('kid is a shabi'))// ['0':"kid is a"]
```


### 贪婪模式和懒惰模式
##### 贪婪模式
" * "限定符和" + "限定符都是__贪婪的__，因为它们会尽可能多的匹配文字，

如：`<img src="test.jpg" width="60px" height="80px"/>`如果用正则匹配src中内容非懒惰模式匹配`/src=".*"/`

匹配结果是：`src="test.jpg" width="60px" height="80px"`意思是从="往后匹配，直到最后一个"匹配结束

##### 懒惰模式正则：


在它们的后面加上一个?就可以实现非贪婪或最少匹配。

`/src=".*?"/`

结果：`src="test.jpg"`因为匹配到第一个"就结束了一次匹配。不会继续向后匹配。因为他懒惰嘛。




```
const str = `<img src="test.jpg" width="60px" height="80px"/>`

const reg = /src=".*?"/

console.log(reg.test(str))
console.log(reg.exec(str))

```
