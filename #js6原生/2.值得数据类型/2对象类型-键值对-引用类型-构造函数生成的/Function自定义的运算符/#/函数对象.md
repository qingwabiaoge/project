# 实例的所有属性(真实数据结构) in

```js
  const Fn = function () {
    console.log(Fn.arguments)
    console.log(Fn.arguments.callee)
  }
  Fn.staticMethod1 = function () {
  }
  Fn.staticMethod2 = function () {
  }
  Fn.prototype={}
  console.log({Fn})
```



![1567864824530](img/1567864824530.png)



### 新建函数对象

##### 字面量

```js
    //1.函数的定义
    function Fn(a1,b1){
        return a1+b1;
    }
    Fn.age = 100;
    console.log(Fn(1,1));//2
    console.log( Fn.age )
```

```js

   var Fn2 = function(a1,b1){
        return a1+b1;
    };
    console.log(Fn2(1,1));//2
    console.log(Fn2)
```

​                               es6语法造成的误解

```js
  data = {
    a: 1,
    function() {
      console.log(123)

    }
  }


  //上面等价于

  data = {
    a: 1,
    function: function () {
      console.log(123)

    }
  }

```

##### new Function

```js
var Fn3 = new Function("a1,b1","return a1+b1;");
console.log({Fn3})
Fn3.age = 100;
console.log(Fn3(1,1));//2
console.log(Fn3.age);//100
```
​                     字符串转函数

```js
  const obj = {}
  const arr = [{name: 'article'}, {name: 'goods'}]
  arr.forEach(item => obj[item.name] = new Function('return ' + JSON.stringify(item))
  )
  console.log(obj)

  console.log(obj.article())
```

##### 参数个数模拟重载

```js
  function fn(i, m) {
    if (arguments.length === 1) {
      return 1
    } else if (arguments.length === 2) {
      return 2
    } else {
      return 0
    }

  }

  console.log(fn(), fn(1), fn(1, 2))


##### 函数是可以和()计算的特殊对象

###### return 设置返回值

1. 制造新指令fn()(返回任意值) 
2. 闭包(返回函数)
3. 柯利化函数(返回函数)
4. new Fn(p1,px)(返回Fn类型的对象)

​```javascript
//1.直接生成对象,无构造函数参与
obj={a:1,b:2}
obj=new Object({a:1,b:2})
//2.构造函数版生成对象,构造函数参与

function Fn(a,b) {
  this.a=a;
  this.b=b
}
Fn.prototype={c:3} //固定部分

obj=new Fn()
```

##### fn()

1. 运行特定代码段
2. 多次运行

自执行

```
   (function () {
                var i=0
                i += 1
                i *=5
                console.log(i)
            })()
```

声明函数,然后执行区别于声明变量,父作用域上下文栈准备阶段 f已经赋值

```
     function f() {
                        var i=0
                        i += 1
                        i *=5
                        console.log(i)
                    }
             f()
```

赋值执行-递归

采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

```js
var print = function x(){
  console.log(typeof x);
};

console.log(x)
// ReferenceError: x is not defined

print()
// function
```

```js
//无限递归
 var print = function fn() {
        console.log('1')
        fn()
    };
    print()

```

赋值给f后f()执行

```js
        var f=function () {
                    var i=0
                    i += 1
                    i *=5
                    console.log(i)
                }
         f()

```

回调参数 函数做参数

```js
function fn2(f) {
    var i = 2
    f()//调到fn里执行,确定argument和this
}


var i = 1
fn2(function fn(arg) {//1函数声明 自由变量在哪个作用域取值在声明时间已经确定
    console.log(i)
    console.log(arg)//undefind
})

```

赋值执行5-闭包

```js
    var i = 1
    var fn = function () {
        var i = 2

        function fn2() {
            console.log(i)
        }

        return fn2
    }
    var f = fn() //fn2的地址复制给f
    f()//2
```

obj.fn() 先计算出地址再运行

```js
     obj={fn:function () {
            console.log(this)
        }}
  
    obj.fn()//obj和fn和()一起计算时,this===obj
```

```js
    cosnt obj = {a: 1}
     obj.fn = function () {
        console.log(this)
    }
   
    const f=obj.fn  //obj.fn先计算得到了内存地址
    f() //f和()计算,this===windows
```

arry

```
arr=[function () {
    console.log(1)
},2]
    arr[0]()
```

require'xxx'()
     

```
 moudle.exports=route(){.....}
 -------------------------  
 const route=require('route')()
```

指定this的值运行

```
  fn.call(obj,a,b)
```

指定参数运行

```
 var f=function (i) {
                
                i += 1
                i *=5
                console.log(i)
            }
     f(1)

```

==这里很特殊==

```
    function fn() {
        console.log(arguments) //[1,2]
    }

    fn(1,2)
```

在指定时间执行

```
  setTimeout(function(){},3000)  
```

异步事件调用执行

```
 事件驱动(onclik事件触发运行)
 vue-router路由切换钩子触发构造函数运行,造成了局部组件
 vue异步组件:切换路由 会触发webpack下载代码事件和异步运行vue构造函数
```

### __ proto __:Function.protype

```javascript
  //1.原型属性Function.prototype---------------
   console.log({'Function.protype': Object.getPrototypeOf(fn)})
  /*{ 
    apply: ? apply()
    arguments: (...)
    bind: ? bind()
    call: ? call()
    caller: (...)
    constructor: ? Function()
    length: 0
    name: ""
    toString: ? toString()
    Symbol(Symbol.hasInstance): ? [Symbol.hasInstance]()
    get arguments: ? ()
    set arguments: ? ()
    get caller: ? ()
    set caller: ? ()
    }*/

```

### OwnProperty

```js
  //2.Own属性,Function构造生成---------------------    
    console.log(Object.getOwnPropertyNames(Fn))//(6)["length", "name", "arguments", "caller", "prototype","staticMethod1","staticMethod2"]

```

### keys

```js
    //3.ennumerable:静态变量,静态方法--------------------
     console.log(Object.keys(Fn)) //[staticMethod1,staticMethod2]

     //for..in还能枚举出 

    for (item in f) {
        console.log(item) //staticMethod1,staticMethod2

    }
```

