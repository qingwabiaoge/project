# 函数是可以和()计算的特殊对象

### return 设置返回值

1. 制造新指令fn()(返回任意值) 
2. 闭包(返回函数)
3. 柯利化函数(返回函数)
4. new Fn(p1,px)(返回Fn类型的对象)

```javascript
//1.直接生成对象,无构造函数参与
obj={a:1,b:2}
obj=new Object({a:1,b:2})
//2.构造函数版生成对象,构造函数参与

function Fn(a,b) {
  this.a=a;
  this.b=b
}
Fn.prototype={c:3} //固定部分

obj=new Fn()
```

### fn()

1. 运行特定代码段
2. 多次运行

自执行

```
   (function () {
                var i=0
                i += 1
                i *=5
                console.log(i)
            })()
```

声明函数,然后执行区别于声明变量,父作用域上下文栈准备阶段 f已经赋值

```
     function f() {
                        var i=0
                        i += 1
                        i *=5
                        console.log(i)
                    }
             f()
```

赋值执行-递归

采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

```js
var print = function x(){
  console.log(typeof x);
};

console.log(x)
// ReferenceError: x is not defined

print()
// function
```

```js
//无限递归
 var print = function fn() {
        console.log('1')
        fn()
    };
    print()

```

赋值给f后f()执行

```js
        var f=function () {
                    var i=0
                    i += 1
                    i *=5
                    console.log(i)
                }
         f()

```

回调参数 函数做参数

```js
function fn2(f) {
    var i = 2
    f()//调到fn里执行,确定argument和this
}


var i = 1
fn2(function fn(arg) {//1函数声明 自由变量在哪个作用域取值在声明时间已经确定
    console.log(i)
    console.log(arg)//undefind
})

```

赋值执行5-闭包

```js
    var i = 1
    var fn = function () {
        var i = 2

        function fn2() {
            console.log(i)
        }

        return fn2
    }
    var f = fn() //fn2的地址复制给f
    f()//2
```

obj.fn() 先计算出地址再运行

```js
     obj={fn:function () {
            console.log(this)
        }}
  
    obj.fn()//obj和fn和()一起计算时,this===obj
```

```js
    cosnt obj = {a: 1}
     obj.fn = function () {
        console.log(this)
    }
   
    const f=obj.fn  //obj.fn先计算得到了内存地址
    f() //f和()计算,this===windows
```

arry

```
arr=[function () {
    console.log(1)
},2]
    arr[0]()
```

require'xxx'()
     

```
 moudle.exports=route(){.....}
 -------------------------  
 const route=require('route')()
```

指定this的值运行

```
  fn.call(obj,a,b)
```

指定参数运行

```
 var f=function (i) {
                
                i += 1
                i *=5
                console.log(i)
            }
     f(1)

```

==这里很特殊==

```
    function fn() {
        console.log(arguments) //[1,2]
    }

    fn(1,2)
```

在指定时间执行

```
  setTimeout(function(){},3000)  
```

异步事件调用执行

```
 事件驱动(onclik事件触发运行)
 vue-router路由切换钩子触发构造函数运行,造成了局部组件
 vue异步组件:切换路由 会触发webpack下载代码事件和异步运行vue构造函数
```
