<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<body>
<script>
    var a = 1
    a = 2 //通过赋值改变变量

    a += 12//赋值操作符+运算符
    a-- //赋值操作符+运算符
    a = 34 * 56//赋值操作符+运算符
    a = typeof a//赋值操作符+操作符  //number
    a = 2 > 1//赋值操作符+关系操作符
    console.log(a)
    a= a instanceof(Boolean)
    console.log(a)
    a = true == 1//赋值操作符+相等操作符
    if (a) {  //语句
        a = 10

    }
    else {
        a = 20
    }


    a = false ? 10 : 20 //赋值操作符+三目运算符 //20
    a = 1 || false //赋值+运算符  //1
    a = false && 10//赋值+运算符  //false


    a = function () {//赋值函数表达式
        return 1
    }
    a = (function () {    //赋值函数值返回值
        return 1
    })()


    a = 'abcd'
    a = a.split('')// 通过对象的实例化方法改变值+通过赋值建立新变量
    a = Array.isArray(a)//通过函数方法改变值,这和普通函数改变值没什么区别


    let obj = {a: 1, b: 2}
    obj = {a: 10, b: 20}//通过赋值不同地址改变变量
    obj.c = 30 //通过键值赋值改变变量,但是没有改变地址

    let obj2 = obj //建立新的变量指向同一个内存地址
    obj2.d = 4//由于指向同一个内存地址 obj也被改变
    obj2 = null//释放变量


    function f() {//函数是一组赋值运算符+若干运算符+若干操作符
        this.a = 200
    }

    f()//window环境改变window里的变量值


    f.call(obj)//函数在obj环境中运行 更改this的值 更改obj的数据

    obj.e = f //f的类字符串值赋值给.....

    obj.e()// 执行被obj封装的函数e

    var c = 0

    function f1(x) {//赋值操作x=c,作为临时变量并没有挂载在window
        c--//改变自由变量c的值
        return ++x// 改变临时变量参数x的值 并非改变外部变量c的值  先相加再返回
    }

    var d = f1(c)//1,运行函数,运行了一批指令改变了现有的变量值,函数return值赋值给了d


    /* 函数表达式 封装了若干指令的集合 是一种变量的数据结构
     function () {
         a=a+2
         return a
     }
 */
    var e = function () {//函数表达式赋值给e
        this.a  += 2
        return a
    }


    f = e()//运行函数赋值return返回值,把返回值赋值给f, return只是取函数内部的值和函数表达式本身没关系


</script>
</body>
</html>