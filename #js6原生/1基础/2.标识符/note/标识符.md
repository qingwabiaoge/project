# 标识符命名(已整理)

### 命名表达语义和类型

##### String:第一属性

```		
title
name
```

##### Number类:定义数量

###### 名词

`total age`

###### 形容词+名词

`minNum, maxNum  aveCount`

##### 返回Boolen值的函数:定义判断

###### 下边的动词前缀+名词

| 动词 | 含义                         | 返回值                                                |
| ---- | ---------------------------- | ----------------------------------------------------- |
| can  | 判断是否可执行某个动作(权限) | 函数返回一个布尔值。true：可执行；   false：不可执行  |
| has  | 判断是否含有某个值           | 函数返回一个布尔值。true：含有此值；false：不含有此值 |
| is   | 判断是否为某个值             | 函数返回一个布尔值。true：为某个值；false：不为某个值 |

###### 其他的动词

```
done 在事情完成之前把done设为false,完成之后设为true 
error 在错误发生之前把error设为false,在已经发生时设为true 
found 在没有找到的时候把found设为false,一旦找到就设为true（在一个数组中查找某个值，在文件中搜寻某员工的ID等） 
success或者ok 操作失败为false，操作成功时为true  
disabled
clearable
```

##### Funcion类:定义动作

###### 单个动词

```
get 获取/set 设置,
add 增加/remove 删除
create 创建/destory 移除
start 启动/stop 停止
open 打开/close 关闭,
read 读取/write 写入
load 载入/save 保存,
create 创建/destroy 销毁
begin 开始/end 结束,
backup 备份/restore 恢复
import 导入/export 导出,
split 分割/merge 合并
inject 注入/extract 提取,
attach 附着/detach 脱离
bind 绑定/separate 分离,
view 查看/browse 浏览
edit 编辑/modify 修改,
select 选取/mark 标记
copy 复制/paste 粘贴,
undo 撤销/redo 重做
insert 插入/delete 移除,
add 加入/append 添加
clean 清理/clear 清除,
index 索引/sort 排序
find 查找/search 搜索,
increase 增加/decrease 减少
play 播放/pause 暂停,
launch 启动/run 运行
compile 编译/execute 执行,
debug 调试/trace 跟踪
observe 观察/listen 监听,
build 构建/publish 发布
input 输入/output 输出,
encode 编码/decode 解码
encrypt 加密/decrypt 解密,
compress 压缩/decompress 解压缩
pack 打包/unpack 解包,
parse 解析/emit 生成
connect 连接/disconnect 断开,
send 发送/receive 接收
download 下载/upload 上传,
refresh 刷新/synchronize 同步
update 更新/revert 复原,
lock 锁定/unlock 解锁
check out 签出/check in 签入,
submit 提交/commit 交付
push 推/pull 拉,
expand 展开/collapse 折叠
begin 起始/end 结束,
start 开始/finish 完成
enter 进入/exit 退出,
abort 放弃/quit 离开
obsolete 废弃/depreciate 废旧,
collect 收集/aggregate 聚集
```

```
//表单方法动词
reset 
submit
clear
validation
```

###### 动词+名词(动宾结构)

常用动词前缀

| 动词 | 含义                         | 返回值 |
| ---- | ------------------- | --------------------- |
| get  | 获取某个值                   | 函数返回一个非布尔值                                  |
| set  | 设置某个值                   | 无返回值、返回是否设置成功或者返回链式对象            |
| load | 加载某些数据                 | 无返回值或者返回是否加载完成的结果                    |

```
getGoods
setTable
```

vue模块网络请求函数的动词和后端的名词一致

```
getGoods() getGoodss(/)
postGoods() 
delGoods() 
patchGoods()   //更新某些字段
putGoods()    //更新所有字段
```

*注:后端路由*

```
router
  .get('/goods/:_id', goods.get)
  .get('/goodss', goods.gets)
  .post('/goods',  goods.post)
  .del('/goods',  goods.del)
  .del('/Goodss',  goods.dels)
  .patch('/goods',  goods.patch)

```

###### 对象.动词

```
Dog.update(conditions, update, callback)
```

##### Object:定义一个实例

###### 名词

produce, news

###### 名词+名词

修饰性名词+名词 

偏正短语(定语+主语)

```
customGoods
```

ui名词+名词

偏正短语(定语+主语),

```
tableData
formValue
```

###### 形容词+名词

偏正短语(定语+主语),

```
imp: important重要的
init： initialization初始化、最初的
con：content内容 

```

##### Array :定义一组实例

###### 名词+s

```
goodss
```

### 命名表达性质

##### 类

首字母大写

##### 类的私有变量

```
_name
```

##### 实例的方法

```javascript
$store
```

##### 常量  (全部大写)

```
const MAX_COUNT = 10;
const URL = 'http://www.foreverz.com';
```

##### 全局变量

```
g_color
```

### 命名表达类型


变量命名类型	| 变量命名前缀
---|---
array 数组	| a
boolean 布尔值 |	b
function 函数	|fn
int 整型 |	i
float 浮点数	| l
object 对象|	o
regular 正则	 |r
string 字符串	 |s

### 注释

1. 多行注释

- 说明：以 /* 开头， */ 结尾
- 语法：/* 注释说明 */
- 使用方法：若开始/*和结束*/都在一行，推荐采用单行注释。若至少三行注释时，第一行为/*，最后行为*/，其他行以*开始，并且注释文字与*保留一个空格。

示例:

```
/*
* 代码执行到这里后会调用setTitle()函数
* setTitle()：设置title的值
*/
setTitle();
```

1. 函数(方法)注释

- 说明：函数(方法)注释也是多行注释的一种，但是包含了特殊的注释要求，参照JSDoc
- 语法：

```
/** 
* 函数说明 
* @关键字 
*/
```

常用注释关键字：(只列出一部分，并不是全部)

| 注释名   | 语法                                      | 含义                 | 示例                                         |
| -------- | ----------------------------------------- | -------------------- | -------------------------------------------- |
| @param   | @param 参数名 {参数类型} 描述信息         | 描述参数的信息       | @param name {String} 传入名称                |
| @return  | @return {返回类型} 描述信息               | 描述返回值的信息     | @return {Boolean} true:可执行;false:不可执行 |
| @author  | @author 作者信息 [附属信息：如邮箱、日期] | 描述此函数作者的信息 | @author 张三 2015/07/21                      |
| @version | @version XX.XX.XX                         | 描述此函数的版本号   | @version 1.0.3                               |
| @example | @example 示例代码                         | 演示函数的使用       | @example setTitle(‘测试’)                    |

```
/**
* 合并Grid的行
* @param grid {Ext.Grid.Panel} 需要合并的Grid
* @param cols {Array} 需要合并列的Index(序号)数组；从0开始计数，序号也包含。
* @param isAllSome {Boolean} ：是否2个tr的cols必须完成一样才能进行合并。true：完成一样；false(默认)：不完全一样
* @return void
* @author polk6 2015/07/21 
* @example
* _________________                             _________________
* |  年龄 |  姓名 |                             |  年龄 |  姓名 |
* -----------------      mergeCells(grid,[0])   -----------------
* |  18   |  张三 |              =>             |       |  张三 |
* -----------------                             -  18   ---------
* |  18   |  王五 |                             |       |  王五 |
* -----------------                             -----------------
*/
function mergeCells(grid: Ext.Grid.Panel, cols: Number[], isAllSome: boolean = false) {
  // Do Something
}
```

- 不要保存 this 的引用。使用 Function#bind。

```
// bad
function () {
  var self = this;
  return function () {
    console.log(self);
  };
}

// bad
function () {
  var that = this;
  return function () {
    console.log(that);
  };
}

// bad
function () {
  var _this = this;
  return function () {
    console.log(_this);
  };
}

// good
function () {
  return function () {
    console.log(this);
  }.bind(this);
}
```

- 给函数命名。这在做堆栈轨迹时很有帮助。

```
// bad
var log = function (msg) {
  console.log(msg);
};

// good
var log = function log(msg) {
  console.log(msg);
};
```

- 如果你的文件导出一个类，你的文件名应该与类名完全相同。

```
// file contents
class CheckBox {
  // ...
}
module.exports = CheckBox;

// in some other file
// bad
var CheckBox = require('./checkBox');

// bad
var CheckBox = require('./check_box');

// good
var CheckBox = require('./CheckBox');
```



# js网上的命名规范(未整理)

### 1. 目的

提高代码可预测性和可维护性的方法是使用命名约定，这就意味着采用一致的方法来对变量和函数进行命名。

### 2. 变量名

变量名包括全局变量，局部变量，类变量，函数参数

### 3. 构造函数（类）命名

首字母大写，驼峰式命名。

JS中没有类，但是可以用new调用构造函数：var man = new Person();

### 4. 普通变量命名

首字母小写，驼峰式命名，匈牙利命名

如：nCheckCount 表示整形的数值

### 5. 匈牙利命名法

匈牙利命名法语法：变量名＝类型＋对象描述

- 类型指变量的类型
- 对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。

提示: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型

| JavaScript变量起名类型  | 变量命名前缀 | 举例                |
| ----------------------- | ------------ | ------------------- |
| Array 数组              | a            | aList，aGroup       |
| Boolean 逻辑            | b            | bChecked，bHasLogin |
| Function 函数           | f            | fGetHtml，fInit     |
| Integer 数字            | n            | nPage，nTotal       |
| Object 对象             | o            | oButton，oDate      |
| Regular Expression 正则 | r            | rDomain，rEmail     |
| String 字符             | s            | sName，sHtml        |

### 6. 其他前缀规范

可根据团队及项目需要增加

- $：表示Jquery对象例如：$Content，$Module，一种比较广泛的Jquery对象变量命名规范。
- fn：表示函数例如：fnGetName，fnSetAge；和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。

### 7. 例外情况

以根据项目及团队需要，设计出针对项目需要的前缀规范，从而达到团队开发协作便利的目的。

- 作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。
- 循环变量可以简写，比如：i，j，k等。
- 某些作为不允许修改值的变量认为是常量，全部字母都大写。例如：COPYRIGHT，PI。常量可以存在于函数中，也可以存在于全局。必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据。

### 8. 函数命名

普通函数：首字母小写，驼峰式命名，统一使用动词或者动词+名词形式

例如：fnGetVersion()，fnSubmitForm()，fnInit()；涉及返回逻辑值的函数可以使用is，has，contains等表示逻辑的词语代替动词，例如：fnIsObject()，fnHasClass()，fnContainsElment()。

内部函数：使用_fn+动词+名词形式，内部函数必需在函数最后定义。

例如：

```
function fnGetNumber(nTotal) {
    if (nTotal < 100) {
        nTotal = 100;
    }
    return _fnAdd(nTotal);

    function _fnAdd(nNumber) {
        nNumber++;
        return nNumber;
    }
}
alert(fGetNumber(10)); //alert 101
```

对象方法与事件响应函数：对象方法命名使用fn+对象类名+动词+名词形式；

例如： fnAddressGetEmail()，

事件响应函数：fn+触发事件对象名+事件名或者模块名

例如：fnDivClick()，fnAddressSubmitButtonClick()

函数方法常用的动词：



### 9. 变量命名例子

- 为什么需要这样强制定义变量前缀？正式因为javascript是弱语言造成的。在定义大量变量的时候，我们需要很明确的知道当前变量是什么属性，如果只通过普通单词，是很难区分的。普通代码var checked = false; var check = function() { return true; } /** some code **/ if(check) {//已经无法很确切知道这里是要用checked还是check()从而导致逻辑错误 //do some thing } 规范后代码var bChecked = false; var fnCheck = function() { return true; } /** some code **/ if(bChecked) { // do some thing } if(fnCheck()) { // do other thing }
- 如何标明私有方法或私有属性？var person = { getName: function () { return this._getFirst() + ' ' + this._getLast(); }, _getFirst: function () { //... }, _getLast: function (){ //... } }; 在这个例子中，getName()以为这这是API的一个公开的方法，而_getFirst()和_getLast()意味着这是一个私有函数。尽管他们都是普通的公开方法，但是使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确保一定能够正常工作，不能直接调用。
- 总结：下面是一些使用下划线约定的变量使用下划线结尾来表明是私有变量，例如name_和getElements_()。使用一个下划线前缀来表示受保护属性，使用两个下划线前缀来表示私有属性。

# 表达式的语义化

```javascript
//定义动作
const callback = require('../callback')
//定义实例
const Dog = require('../../model/Dog')
//定义条件
const conditions = {name: '小黑'}; //也不能指定id创建
//定义动词
const update = {$set: {age: 100}};

//定义实例的属性和方法:------------------------------------------------------

//狗.更新	(当名字叫小黑时)
Dog.update(conditions, update, callback)

// 小黑保存
xiaohei.save(callback)
//小黑的年纪
xiaohei.age

```

# 语句语义化

### 定义变量

描述一个名词实例

```
//变量声明===描述名词
const conditions = {name: '小黑'}; //也不能指定id创建
const update = {$set: {age: 100}};
```

### 条件语句

表示选择

```
if(){}
else( ){}
```

