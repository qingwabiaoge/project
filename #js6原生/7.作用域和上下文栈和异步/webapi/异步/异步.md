# 异步的特征
1. 另开进程执行,bom的setTimeout和dom事件都是异步的
2. 同进程的异步队列排队等待

# 异步的方式

后一个任务等待前一个任务结束再执行。程序执行顺序与任务排列顺序一致的，同步的。

参考：

　　http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html

　　https://segmentfault.com/q/1010000000140970

在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。

因此callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。

### 1、一个同步(阻塞)中使用回调的例子



```
var func1=function(callback){
    //do something.
    (callback && typeof(callback) === "function") && callback();
}
var func2=function(){}
func1(func2);
   
```



### 2、改进为异步操作，不阻塞。异步编程的方法一：回调函数



```
function f1(callback){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　callback();
　　　　}, 1000);
　　}
f1(f2)
```



采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。

回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度[耦合](http://en.wikipedia.org/wiki/Coupling_(computer_programming))（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。

### 3、回调总结

异步回调的例子：



```
$(document).ready(callback);

$.ajax({
  url: "test.html",
  context: document.body
}).done(function() { 
  $(this).addClass("done");
}).fail(function() { alert("error");
}).always(function() { alert("complete"); 
});
/**
注意的是，ajax请求确实是异步的,不过这请求是由浏览器新开一个线程请求,当请求的状态变更时,如果先前已设置回调,这异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。见：http://www.phpv.net/html/1700.html
*/
```



 

*回调什么时候执行*

回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。

*回调函数的使用场合*

- 资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。

- DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。

- setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现

- 链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现

- setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的
- 结果通知给代理函数进行及时处理。

 

*回调函数的传递*

上面说了，要将函数引用或者函数表达式作为参数传递。



- ```
  $.get('myhtmlpage.html', myCallBack);//这是对的
  $.get('myhtmlpage.html', myCallBack('foo', 'bar'));//这是错的，那么要带参数呢？
  $.get('myhtmlpage.html', function(){//带参数的使用函数表达式
  myCallBack('foo', 'bar');
  });
  ```

  另外，最好保证回调存在且必须是函数引用或者函数表达式：
  (callback && typeof(callback) === "function") && callback();

### 4、异步编程的方法二：事件监听（和发布订阅模式原理一样）

事件监听：

```
var doc = $(document);
    function f2(){
        console.log("done");
    }
    function f1(){
        setTimeout(function(){
            doc.trigger("done")
        }, 1000);
    }
    doc.on("done", f2);
    f1();
```



发布订阅：和事件监听一模一样啊。

观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。



```
var Observable = {//doc
  callbacks: [],
  add: function(fn) {
    this.callbacks.push(fn);
  },
  fire: function() {
    this.callbacks.forEach(function(fn) {
      fn();
    })
  }
}
Observable.add(function() {
  alert(1)
})

Observable.add(function() {
  alert(2)
})
Observable.fire(); // 1, 2
```



 

### 4、异步编程的方法三：promise对象

Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供[统一接口](http://wiki.commonjs.org/wiki/Promises/A)。

简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：

> 　　f1().then(f2);

f1要进行如下改写（这里使用的是jQuery的[实现](http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html)）：

> 　　function f1(){
>
> 　　　　var dfd = $.Deferred();
>
> 　　　　setTimeout(function () {
>
> 　　　　　　// f1的任务代码
>
> 　　　　　　dfd.resolve();
>
> 　　　　}, 500);
>
> 　　　　return dfd.promise;
>
> 　　}

这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的[配套方法](http://api.jquery.com/category/deferred-object/)，可以实现许多强大的功能。

比如，指定多个回调函数：

> 　f1().then(f2).then(f3);

再比如，指定发生错误时的回调函数：

> 　　f1().then(f2).fail(f3);

而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。

### 5、es7语法糖async/await

　　　　　async异步函数是promise的完成状态，async函数直接then去获取状态改变值，catch来获取错误

　　　　　await只允许在async内部使用，就是async异步函数内部想要继续then，就可以采用await异步函数，await异步函数是内部的async异步函数

　　　　  async极大精简了promise的操作　　　



```
async  function asyncFn(){
        return 123;
    }
    asyncFn()
        .then(x => {console.log(x)})
        .catch(err => console.log(error))
```



　　　　这是未精简的promise操作，功能是把最终结果return最外层的promise，但是 用到了多层嵌套，比较复杂



```
    const fn = () => {
        return getJSON()
            .then(data =>{
                if(data.params){
                    return otherGetJSON(data).then(otherdata =>{
                        console.log(otherdata);
                        return otherdata;
                    })
                }else{
                    console.log(data)
                }
            })
    }
```



　　　　而async异步函数，直接去return出结果就行，这就是await是async内部async异步函数



```
    const fn = async () => {
        const data = await getJSON();
        if(data.params){
            const otherdata = await otherGetJSON(data);
            console.log(otherdata);
            return otherdata;
        }else{
            console.log(data)
            return data;
        }
    }
```



### 6、co库的generator函数

　　　　　　generator函数是一个异步函数，只有异步操作有结果才会交还执行权

　　　　　　generator用到了ES6的遍历Iterator的概念，创建一个指针对象，指向数据结构的起始位置，每次next指向下一个指针结构成员，直至指向的下一个结构成员为undefined

　　　　　　generator概念就是，每次遍历读用next方法，内部指针从结构头部指向下一个结构成员，直至下一个结构成员为undefined，遇到yield或return时会返回value和done参数，value表示yield或return的值，done表示是否结束　



```
function * gen(x){
      var y = yield x +2;      
      return y;  
}
var g = gen(1);
console.log(g.next()) // { value: 3, done: false }
console.log(g.next()) // { value: undefined, done: true }
```



　　　　　　yield是遍历的停止标志

　　　　　　而generator中的yield*表示 yield* 后面跟着一个可遍历的结构