# Node.js Buffer(缓冲区)

JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。

但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。

在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。**一个 Buffer 类似于一个整数数组**，但它对应于 V8 堆内存之外的一块原始内存。

# 创建Buffer对象（缓冲区数据）

### 读取utf8格式的字符串创建Buffer对象

```js
var buffer = new Buffer.from('Hello Node');  //<Buffer 48 65 6c 6c 6f 20 4e 6f 64 65>

```

### 创建其他类型的

可接受的编码格式包括：ascii、utf8、utf16le(ucs2)、base64、binary、hex

```js
var buffer = new Buffer.from('48656c6c6f204e6f6465', 'hex');
console.log(buffer.toString())//hello node
```

### 建立指定容量的buffer对象

缓冲区没有具体初始化内容时，可以指定长度来创建缓冲区，例如，创建长度为1024字节的缓冲区：

```js
var buffer = new Buffer.from(1024);
```

### 错误例子

```js
var buffer = new Buffer.from('Hello Node','base64'); //会乱码
```

### 不同编码占用缓存区的大小

```
console.log(Buffer.from('fhqwhgads', 'ascii'));
// 打印: <Buffer 66 68 71 77 68 67 61 64 73>
console.log(Buffer.from('fhqwhgads', 'utf16le'));
// 打印: <Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>
```

# 2.缓冲区对象编码  解码、转码

#### 编码  解码

utf8编码解码

```js
var buffer = new Buffer.from('Hello Node');//<Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
console.log(buffer.toString());			//->Hello Node
```

ascii编码解码

```
const buf = Buffer.from('hello world', 'ascii');
console.log(buf) //<Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
console.log(buf.toString('ascii'));//hello world


```

### 转码

```js
//把utf-8编码的字符串写入到缓冲区
var buffer = new Buffer.from('Hello Node');
//缓冲区转码到base64字符串
var base64=buffer.toString('base64')		//  ->  SGVsbG8gTm9kZQ==
//把base64字符串写入到缓存区
var buffer2=new Buffer.from(base64,'base64')
//把缓存区内容输出成utf-8
console.log(buffer2.toString('utf-8'))//helloword

```



# 缓冲区编辑

### 缓冲区的切分、复制

缓冲区创建后，需要将一部分数据提取出来时，可以通过指定起始和结束位置来切分缓冲区：

```js
var longBuffer = new Buffer.from('this is a long Buffer.from');
var smallBuffer = longBuffer.slice(5, 12);
console.log(smallBuffer.toString());		//	->	is a lo
```

缓冲区切分并没有分配新的内存，还是使用的父缓冲区的内存区域，只是引用了父缓冲区不同的起始/结束位置。修改父缓冲区重合部分的数据，修改也会影响子缓冲区，修改子缓冲区也会影响父缓冲区。父缓冲区操作结束后，由于子缓冲区还存在，因此内存依然被保留，使用不当会造成内存泄漏。

使用copy方法代替slice可以将数据从一个缓冲区复制到另一个缓冲区，解决内存泄漏问题：

```js
var longBuffer = new Buffer.from('this is a long Buffer.from');
var smallBuffer = new Buffer.from(7); longBuffer.slice(5, 12);
longBuffer.copy(smallBuffer, 0, 5, 12)
smallBuffer[3] = 119;
console.log(smallBuffer.toString());		//	->	is w lo
console.log(longBuffer.toString());		// ->  this is a long Buffer.from //父缓冲区未子缓冲区修改的影响
```

### 缓冲区数据的获取和设置

获取指定位置的内容：

```js
var buffer = new Buffer.from('Hello Node'); //<Buffer 48 65 6c 6c 6f 20 4e 6f 64 65>

console.log(buffer[3]);        // ->108
```

设置指定位置的内容：

```js
var buffer = new Buffer.from('Hello Node');
buffer[3]=109;			//设置第4位的数据
console.log(buffer.toString());			//->Helmo Node
```

# 

