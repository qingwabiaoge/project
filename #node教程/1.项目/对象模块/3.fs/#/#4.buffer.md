### 1. 创建缓冲区

用字符串创建缓冲区默认utf-8编码

```js
var buffer = new Buffer.from('Hello Node');  //<Buffer 48 65 6c 6c 6f 20 4e 6f 64 65>

```

Node默认使用UTF-8格式编码，也可以使用其它编码格式的字符串创建缓冲区，制定编码格式作为构造函数的第二个参数即可:

```js
var buffer = new Buffer.from('48656c6c6f204e6f6465', 'hex');
```

可接受的编码格式包括：ascii、utf8、utf16le(ucs2)、base64、binary、hex

缓冲区没有具体初始化内容时，可以指定长度来创建缓冲区，例如，创建长度为1024字节的缓冲区：

```js
var buffer = new Buffer.from(1024);
```

### 2. 缓冲区数据的获取和设置

获取指定位置的内容：

```js
var buffer = new Buffer.from('Hello Node'); //<Buffer 48 65 6c 6c 6f 20 4e 6f 64 65>

console.log(buffer[3]);        // ->108
```

设置指定位置的内容：

```js
var buffer = new Buffer.from('Hello Node');
buffer[3]=109;			//设置第4位的数据
console.log(buffer.toString());			//->Helmo Node
```



### 3. 缓冲区数据解码、转码

缓冲区转换为UTF-8格式的字符串：

```js
var buffer = new Buffer.from('Hello Node');
console.log(buffer.toString());			//->Hello Node
```

将缓冲区数据转换为base64格式字符串：

```js
var buffer = new Buffer.from('Hello Node');
console.log(buffer.toString('base64'));			//  ->  SGVsbG8gTm9kZQ==
```

将base64编码的字符串，转换为UTF-8编码：

```js
var base64String = 'SGVsbG8gTm9kZQ==';
var buffer = new Buffer.from(base64String, 'base64');
var utf8String = buffer.toString('utf8');
console.log(utf8String);				//   ->  Hello Node
```

### 4. 不同编码占用缓存区的大小

```js
const str = 'he'

console.log(str.length)  //2

console.log(new Buffer.from(str,'utf-8').length)//2

console.log(new Buffer.from(str,'utf16le').length)//4

console.log(new Buffer.from(str,'base64').length)//1

console.log(new Buffer.from(str,'hex').length)//0

```

```js
const str = '您好'

console.log(str.length)  //2

console.log(new Buffer.from(str,'utf-8').length)//6

console.log(new Buffer.from(str,'utf16le').length)//4

console.log(new Buffer.from(str,'base64').length)//0

console.log(new Buffer.from(str,'hex').length)//0

```

```js
const str = '您好'

console.log(str.length)  //2

console.log(new Buffer.from(str,'utf-8').length)//6

console.log(new Buffer.from(str,'utf16le').length)//4

console.log(new Buffer.from(str,'base64').length)//0

console.log(new Buffer.from(str,'hex').length)//0

```



### 5. 缓冲区的切分、复制

缓冲区创建后，需要将一部分数据提取出来时，可以通过指定起始和结束位置来切分缓冲区：

```js
var longBuffer = new Buffer.from('this is a long Buffer.from');
var smallBuffer = longBuffer.slice(5, 12);
console.log(smallBuffer.toString());		//	->	is a lo
```

缓冲区切分并没有分配新的内存，还是使用的父缓冲区的内存区域，只是引用了父缓冲区不同的起始/结束位置。修改父缓冲区重合部分的数据，修改也会影响子缓冲区，修改子缓冲区也会影响父缓冲区。父缓冲区操作结束后，由于子缓冲区还存在，因此内存依然被保留，使用不当会造成内存泄漏。

使用copy方法代替slice可以将数据从一个缓冲区复制到另一个缓冲区，解决内存泄漏问题：

```js
var longBuffer = new Buffer.from('this is a long Buffer.from');
var smallBuffer = new Buffer.from(7); longBuffer.slice(5, 12);
longBuffer.copy(smallBuffer, 0, 5, 12)
smallBuffer[3] = 119;
console.log(smallBuffer.toString());		//	->	is w lo
console.log(longBuffer.toString());		// ->  this is a long Buffer.from //父缓冲区未子缓冲区修改的影响
```